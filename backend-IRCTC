import React, { useState } from 'react';
import { Download, FileText, Server } from 'lucide-react';

const BackendCode = () => {
  const [selectedFile, setSelectedFile] = useState('server.js');

  const files = {
    'server.js': `// server.js
const express = require('express');
const cors = require('cors');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const sqlite3 = require('sqlite3').verbose();

const app = express();
const PORT = 5000;
const JWT_SECRET = 'your-secret-key-change-in-production';

app.use(cors());
app.use(express.json());

// Database setup
const db = new sqlite3.Database('./irctc.db');

// Initialize database tables
db.serialize(() => {
  // Users table
  db.run(\`CREATE TABLE IF NOT EXISTS users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    email TEXT UNIQUE NOT NULL,
    password TEXT NOT NULL,
    name TEXT NOT NULL,
    phone TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
  )\`);

  // Payment methods table
  db.run(\`CREATE TABLE IF NOT EXISTS payment_methods (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER,
    type TEXT NOT NULL,
    card_number TEXT,
    card_holder TEXT,
    expiry TEXT,
    upi_id TEXT,
    is_default BOOLEAN DEFAULT 0,
    FOREIGN KEY(user_id) REFERENCES users(id)
  )\`);

  // Passengers master list
  db.run(\`CREATE TABLE IF NOT EXISTS passengers (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER,
    name TEXT NOT NULL,
    age INTEGER NOT NULL,
    gender TEXT NOT NULL,
    FOREIGN KEY(user_id) REFERENCES users(id)
  )\`);

  // Trains table
  db.run(\`CREATE TABLE IF NOT EXISTS trains (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    train_number TEXT UNIQUE NOT NULL,
    train_name TEXT NOT NULL,
    source TEXT NOT NULL,
    destination TEXT NOT NULL,
    departure_time TEXT NOT NULL,
    arrival_time TEXT NOT NULL,
    sleeper_seats INTEGER DEFAULT 72,
    ac_3tier_seats INTEGER DEFAULT 64,
    ac_2tier_seats INTEGER DEFAULT 48,
    ac_1tier_seats INTEGER DEFAULT 24,
    sleeper_price REAL,
    ac_3tier_price REAL,
    ac_2tier_price REAL,
    ac_1tier_price REAL
  )\`);

  // Bookings table
  db.run(\`CREATE TABLE IF NOT EXISTS bookings (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER,
    train_id INTEGER,
    booking_date DATE NOT NULL,
    travel_date DATE NOT NULL,
    class TEXT NOT NULL,
    quota TEXT DEFAULT 'General',
    total_fare REAL NOT NULL,
    status TEXT DEFAULT 'Confirmed',
    pnr TEXT UNIQUE NOT NULL,
    payment_method_id INTEGER,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY(user_id) REFERENCES users(id),
    FOREIGN KEY(train_id) REFERENCES trains(id),
    FOREIGN KEY(payment_method_id) REFERENCES payment_methods(id)
  )\`);

  // Booking passengers
  db.run(\`CREATE TABLE IF NOT EXISTS booking_passengers (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    booking_id INTEGER,
    name TEXT NOT NULL,
    age INTEGER NOT NULL,
    gender TEXT NOT NULL,
    berth_preference TEXT,
    seat_number TEXT,
    FOREIGN KEY(booking_id) REFERENCES bookings(id)
  )\`);

  // Insert sample trains
  const sampleTrains = [
    ['12301', 'Rajdhani Express', 'New Delhi', 'Howrah', '16:55', '10:05', 250.00, 650.00, 950.00, 1500.00],
    ['12951', 'Mumbai Rajdhani', 'Mumbai Central', 'New Delhi', '16:25', '08:35', 300.00, 700.00, 1000.00, 1600.00],
    ['12621', 'Tamil Nadu Express', 'New Delhi', 'Chennai', '22:30', '07:20', 200.00, 550.00, 850.00, 1400.00],
    ['12423', 'Rajdhani Express', 'New Delhi', 'Dibrugarh', '19:15', '11:00', 280.00, 680.00, 980.00, 1550.00],
    ['12259', 'Duronto Express', 'Sealdah', 'New Delhi', '16:50', '09:55', 220.00, 600.00, 900.00, 1450.00]
  ];

  const stmt = db.prepare(\`INSERT OR IGNORE INTO trains 
    (train_number, train_name, source, destination, departure_time, arrival_time, 
     sleeper_price, ac_3tier_price, ac_2tier_price, ac_1tier_price) 
    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\`);

  sampleTrains.forEach(train => stmt.run(train));
  stmt.finalize();
});

// Middleware to verify JWT
const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) return res.status(401).json({ error: 'Access denied' });

  jwt.verify(token, JWT_SECRET, (err, user) => {
    if (err) return res.status(403).json({ error: 'Invalid token' });
    req.user = user;
    next();
  });
};

// Auth Routes
app.post('/api/auth/signup', async (req, res) => {
  const { email, password, name, phone } = req.body;

  if (!email || !password || !name) {
    return res.status(400).json({ error: 'Missing required fields' });
  }

  const hashedPassword = await bcrypt.hash(password, 10);

  db.run(
    'INSERT INTO users (email, password, name, phone) VALUES (?, ?, ?, ?)',
    [email, hashedPassword, name, phone],
    function(err) {
      if (err) {
        return res.status(400).json({ error: 'Email already exists' });
      }

      const token = jwt.sign({ id: this.lastID, email }, JWT_SECRET);
      res.json({ token, user: { id: this.lastID, email, name, phone } });
    }
  );
});

app.post('/api/auth/login', (req, res) => {
  const { email, password } = req.body;

  db.get('SELECT * FROM users WHERE email = ?', [email], async (err, user) => {
    if (err || !user) {
      return res.status(400).json({ error: 'Invalid credentials' });
    }

    const validPassword = await bcrypt.compare(password, user.password);
    if (!validPassword) {
      return res.status(400).json({ error: 'Invalid credentials' });
    }

    const token = jwt.sign({ id: user.id, email: user.email }, JWT_SECRET);
    res.json({ 
      token, 
      user: { id: user.id, email: user.email, name: user.name, phone: user.phone } 
    });
  });
});

// User Profile Routes
app.get('/api/user/profile', authenticateToken, (req, res) => {
  db.get('SELECT id, email, name, phone FROM users WHERE id = ?', [req.user.id], (err, user) => {
    if (err || !user) return res.status(404).json({ error: 'User not found' });
    res.json(user);
  });
});

app.put('/api/user/profile', authenticateToken, (req, res) => {
  const { name, phone } = req.body;

  db.run(
    'UPDATE users SET name = ?, phone = ? WHERE id = ?',
    [name, phone, req.user.id],
    (err) => {
      if (err) return res.status(400).json({ error: 'Update failed' });
      res.json({ message: 'Profile updated successfully' });
    }
  );
});

// Payment Methods Routes
app.get('/api/payment-methods', authenticateToken, (req, res) => {
  db.all('SELECT * FROM payment_methods WHERE user_id = ?', [req.user.id], (err, methods) => {
    if (err) return res.status(400).json({ error: 'Failed to fetch payment methods' });
    res.json(methods);
  });
});

app.post('/api/payment-methods', authenticateToken, (req, res) => {
  const { type, card_number, card_holder, expiry, upi_id, is_default } = req.body;

  if (is_default) {
    db.run('UPDATE payment_methods SET is_default = 0 WHERE user_id = ?', [req.user.id]);
  }

  db.run(
    \`INSERT INTO payment_methods (user_id, type, card_number, card_holder, expiry, upi_id, is_default)
     VALUES (?, ?, ?, ?, ?, ?, ?)\`,
    [req.user.id, type, card_number, card_holder, expiry, upi_id, is_default ? 1 : 0],
    function(err) {
      if (err) return res.status(400).json({ error: 'Failed to add payment method' });
      res.json({ id: this.lastID, message: 'Payment method added' });
    }
  );
});

app.delete('/api/payment-methods/:id', authenticateToken, (req, res) => {
  db.run(
    'DELETE FROM payment_methods WHERE id = ? AND user_id = ?',
    [req.params.id, req.user.id],
    (err) => {
      if (err) return res.status(400).json({ error: 'Failed to delete payment method' });
      res.json({ message: 'Payment method deleted' });
    }
  );
});

// Passengers Routes
app.get('/api/passengers', authenticateToken, (req, res) => {
  db.all('SELECT * FROM passengers WHERE user_id = ?', [req.user.id], (err, passengers) => {
    if (err) return res.status(400).json({ error: 'Failed to fetch passengers' });
    res.json(passengers);
  });
});

app.post('/api/passengers', authenticateToken, (req, res) => {
  const { name, age, gender } = req.body;

  db.run(
    'INSERT INTO passengers (user_id, name, age, gender) VALUES (?, ?, ?, ?)',
    [req.user.id, name, age, gender],
    function(err) {
      if (err) return res.status(400).json({ error: 'Failed to add passenger' });
      res.json({ id: this.lastID, message: 'Passenger added' });
    }
  );
});

app.delete('/api/passengers/:id', authenticateToken, (req, res) => {
  db.run(
    'DELETE FROM passengers WHERE id = ? AND user_id = ?',
    [req.params.id, req.user.id],
    (err) => {
      if (err) return res.status(400).json({ error: 'Failed to delete passenger' });
      res.json({ message: 'Passenger deleted' });
    }
  );
});

// Train Routes
app.get('/api/trains/search', (req, res) => {
  const { source, destination, date } = req.query;

  let query = 'SELECT * FROM trains WHERE 1=1';
  const params = [];

  if (source) {
    query += ' AND LOWER(source) LIKE LOWER(?)';
    params.push(\`%\${source}%\`);
  }

  if (destination) {
    query += ' AND LOWER(destination) LIKE LOWER(?)';
    params.push(\`%\${destination}%\`);
  }

  db.all(query, params, (err, trains) => {
    if (err) return res.status(400).json({ error: 'Search failed' });
    res.json(trains);
  });
});

app.get('/api/trains/:id/availability', (req, res) => {
  const { date, class: trainClass } = req.query;
  
  db.get('SELECT * FROM trains WHERE id = ?', [req.params.id], (err, train) => {
    if (err || !train) return res.status(404).json({ error: 'Train not found' });

    // Calculate booked seats for this date
    db.get(
      \`SELECT COUNT(*) as booked FROM booking_passengers bp
       JOIN bookings b ON bp.booking_id = b.id
       WHERE b.train_id = ? AND b.travel_date = ? AND b.class = ? AND b.status = 'Confirmed'\`,
      [req.params.id, date, trainClass],
      (err, result) => {
        const booked = result ? result.booked : 0;
        const total = train[\`\${trainClass.toLowerCase().replace(/\s/g, '_')}_seats\`] || 0;
        const available = Math.max(0, total - booked);

        res.json({
          train,
          availability: {
            class: trainClass,
            total,
            booked,
            available,
            status: available > 0 ? 'Available' : 'Waitlist'
          }
        });
      }
    );
  });
});

// Admin Routes
app.post('/api/admin/trains', authenticateToken, (req, res) => {
  const {
    train_number, train_name, source, destination,
    departure_time, arrival_time, sleeper_price,
    ac_3tier_price, ac_2tier_price, ac_1tier_price
  } = req.body;

  db.run(
    \`INSERT INTO trains (train_number, train_name, source, destination, 
     departure_time, arrival_time, sleeper_price, ac_3tier_price, 
     ac_2tier_price, ac_1tier_price)
     VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\`,
    [train_number, train_name, source, destination, departure_time, 
     arrival_time, sleeper_price, ac_3tier_price, ac_2tier_price, ac_1tier_price],
    function(err) {
      if (err) return res.status(400).json({ error: 'Failed to add train' });
      res.json({ id: this.lastID, message: 'Train added successfully' });
    }
  );
});

// Booking Routes
app.post('/api/bookings', authenticateToken, (req, res) => {
  const { train_id, travel_date, class: trainClass, quota, passengers, payment_method_id } = req.body;

  // Generate PNR
  const pnr = 'PNR' + Date.now() + Math.random().toString(36).substr(2, 6).toUpperCase();

  // Get train details for pricing
  db.get('SELECT * FROM trains WHERE id = ?', [train_id], (err, train) => {
    if (err || !train) return res.status(404).json({ error: 'Train not found' });

    const pricePerPassenger = train[\`\${trainClass.toLowerCase().replace(/\s/g, '_')}_price\`];
    const total_fare = pricePerPassenger * passengers.length;

    db.run(
      \`INSERT INTO bookings (user_id, train_id, booking_date, travel_date, 
       class, quota, total_fare, pnr, payment_method_id, status)
       VALUES (?, ?, DATE('now'), ?, ?, ?, ?, ?, ?, 'Confirmed')\`,
      [req.user.id, train_id, travel_date, trainClass, quota, total_fare, pnr, payment_method_id],
      function(err) {
        if (err) return res.status(400).json({ error: 'Booking failed' });

        const booking_id = this.lastID;

        // Insert passengers
        const stmt = db.prepare(
          \`INSERT INTO booking_passengers (booking_id, name, age, gender, berth_preference, seat_number)
           VALUES (?, ?, ?, ?, ?, ?)\`
        );

        passengers.forEach((p, index) => {
          const seat = \`\${trainClass.charAt(0)}\${Math.floor(Math.random() * 72) + 1}\`;
          stmt.run([booking_id, p.name, p.age, p.gender, p.berth_preference, seat]);
        });

        stmt.finalize();

        res.json({
          booking_id,
          pnr,
          total_fare,
          status: 'Confirmed',
          message: 'Booking successful'
        });
      }
    );
  });
});

app.get('/api/bookings', authenticateToken, (req, res) => {
  db.all(
    \`SELECT b.*, t.train_number, t.train_name, t.source, t.destination
     FROM bookings b
     JOIN trains t ON b.train_id = t.id
     WHERE b.user_id = ?
     ORDER BY b.created_at DESC\`,
    [req.user.id],
    (err, bookings) => {
      if (err) return res.status(400).json({ error: 'Failed to fetch bookings' });

      const bookingsWithPassengers = bookings.map(booking => {
        return new Promise((resolve) => {
          db.all(
            'SELECT * FROM booking_passengers WHERE booking_id = ?',
            [booking.id],
            (err, passengers) => {
              resolve({ ...booking, passengers: passengers || [] });
            }
          );
        });
      });

      Promise.all(bookingsWithPassengers).then(results => res.json(results));
    }
  );
});

app.put('/api/bookings/:id/cancel', authenticateToken, (req, res) => {
  db.run(
    "UPDATE bookings SET status = 'Cancelled' WHERE id = ? AND user_id = ?",
    [req.params.id, req.user.id],
    (err) => {
      if (err) return res.status(400).json({ error: 'Cancellation failed' });
      res.json({ message: 'Booking cancelled successfully' });
    }
  );
});

app.listen(PORT, () => {
  console.log(\`Server running on http://localhost:\${PORT}\`);
});`,

    'package.json': `{
  "name": "irctc-backend",
  "version": "1.0.0",
  "description": "IRCTC Booking System Backend",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "cors": "^2.8.5",
    "jsonwebtoken": "^9.0.2",
    "bcryptjs": "^2.4.3",
    "sqlite3": "^5.1.6"
  },
  "devDependencies": {
    "nodemon": "^3.0.1"
  }
}`,

    'README.md': `# IRCTC Backend API

## Setup

1. Install dependencies:
\`\`\`bash
npm install
\`\`\`

2. Start the server:
\`\`\`bash
npm start
\`\`\`

Or for development with auto-reload:
\`\`\`bash
npm run dev
\`\`\`

Server runs on http://localhost:5000

All protected routes require JWT token in header:
\`\`\`
Authorization: Bearer <token>
\`\`\``
  };

  const downloadFile = (filename) => {
    const content = files[filename];
    const blob = new Blob([content], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
    URL.revokeObjectURL(url);
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 p-8">
      <div className="max-w-6xl mx-auto">
        <div className="bg-white rounded-lg shadow-xl p-6 mb-6">
          <div className="flex items-center gap-3 mb-4">
            <Server className="w-8 h-8 text-blue-600" />
            <h1 className="text-3xl font-bold text-gray-800">IRCTC Backend</h1>
          </div>
          <p className="text-gray-600 mb-4">
            Node.js + Express + SQLite backend with JWT authentication
          </p>
          
          <div className="bg-blue-50 border-l-4 border-blue-500 p-4 mb-6">
            <h3 className="font-semibold text-blue-900 mb-2">Quick Start:</h3>
            <ol className="list-decimal list-inside space-y-1 text-sm text-blue-800">
              <li>Download all files using buttons below</li>
              <li>Run: <code className="bg-blue-100 px-2 py-1 rounded">npm install</code></li>
              <li>Run: <code className="bg-blue-100 px-2 py-1 rounded">npm start</code></li>
              <li>API will be available at http://localhost:5000</li>
            </ol>
          </div>

          <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
            {Object.keys(files).map((filename) => (
              <button
                key={filename}
                onClick={() => setSelectedFile(filename)}
                className={`p-4 rounded-lg border-2 transition-all ${
                  selectedFile === filename
                    ? 'border-blue-500 bg-blue-50'
                    : 'border-gray-200 hover:border-blue-300'
                }`}
              >
                <FileText className="w-6 h-6 mb-2 text-blue-600" />
                <div className="font-semibold text-gray-800">{filename}</div>
              </button>
            ))}
          </div>

          <div className="mb-4 flex justify-between items-center">
            <h2 className="text-xl font-bold text-gray-800">{selectedFile}</h2>
            <button
              onClick={() => downloadFile(selectedFile)}
              className="flex items-center gap-2 bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors"
            >
              <Download className="w-4 h-4" />
              Download
            </button>
          </div>

          <pre className="bg-gray-900 text-gray-100 p-6 rounded-lg overflow-x-auto max-h-96 text-sm">
            <code>{files[selectedFile]}</code>
          </pre>
        </div>

        <div className="bg-white rounded-lg shadow-xl p-6">
          <h2 className="text-2xl font-bold text-gray-800 mb-4">Features</h2>
          <div className="grid md:grid-cols-2 gap-4">
            <div className="border-l-4 border-green-500 pl-4">
              <h3 className="font-semibold text-gray-800 mb-2">Authentication</h3>
              <ul className="text-sm text-gray-600 space-y-1">
                <li>• JWT-based authentication</li>
                <li>• Secure password hashing with bcrypt</li>
                <li>• User signup and login</li>
              </ul>
            </div>
            <div className="border-l-4 border-blue-500 pl-4">
              <h3 className="font-semibold text-gray-800 mb-2">Database</h3>
              <ul className="text-sm text-gray-600 space-y-1">
                <li>• SQLite database</li>
                <li>• Relational data structure</li>
                <li>• Sample train data included</li>
              </ul>
            </div>
            <div className="border-l-4 border-purple-500 pl-4">
              <h3 className="font-semibold text-gray-800 mb-2">Booking System</h3>
              <ul className="text-sm text-gray-600 space-y-1">
                <li>• Real-time availability checking</li>
                <li>• Multiple passenger booking</li>
                <li>• PNR generation</li>
              </ul>
            </div>
            <div className="border-l-4 border-orange-500 pl-4">
              <h3 className="font-semibold text-gray-800 mb-2">Payment</h3>
              <ul className="text-sm text-gray-600 space-y-1">
                <li>• Multiple payment methods</li>
                <li>• Card and UPI support</li>
                <li>• Mock payment processing</li>
              </ul>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default BackendCode;
